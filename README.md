# MatchesDBDemo
 Restful API Demo using SpringBoot


Παρακάτω παρουσιάζεται ένα project δομημένο σε Java Spring-SpringBoot. Θα περιγραφούν με τη σειρά:
1) Οι προσδοκίες από τον κώδικα,
2) Η αρχιτεκτονική του κώδικα,
3) Τα Dependencies κι εργαλεία που χρησιμοποιήθηκαν,
4) Η λογική με την οποία στήθηκε η Σχεσιακή Βάση Δεδομένων,
5) Η βασική ιδέα και οι λειτουργίες των:
    1) Μοντέλων (.models package)
    2) Repositories (.repositories package)
    3) Controllers (.controllers package)
    4) D.T.Os. (.dtos package)
    5) Configuration (.config package)
6) Τα Annotations (πλευρά Spring) και η επιρροή τους στον κώδικα,
7) Το αποτέλεσμα του κώδικα.

_**Οι προσδοκίες από τον κώδικα:**_
Το ζητούμενο ήταν να φιαχτεί ένα λογισμικό το οποίο μπορεί να **λειτουργεί ανεξάρτητα** 
(ή σε docker). Σκοπός αυτού είναι να χρησιμοποιεί μία Βάση Δεδομένων για να **αποθηκεύει** κάποιες 
**πληροφορίες** για τη **διεξαγωγή αγώνων** και πληροφορίες για τα **στοιχήματα-αποτελέσματα** (match odds) 
των αγώνων. Επιπλέον, ζητήθηκε να κατασκευαστεί ένα **A.P.I.**, από την **πλευρά** του **Client**, το οποίο 
**θα επικοινωνεί με τη Βάση Δεδομένων** και θα επιστρέφει ή θα αποστέλλει τις πληροφορίες που 
επιθυμεί ο χρήστης. Αυτή η ανταλλαγή πληροφοριών μεταξύ **Server-Client** θα γίνεται μέσω **Restful 
Operations**.

_**Η αρχιτεκτονική του κώδικα:**_
Το project ακολουθεί το **M.V.C. pattern** (Model-View-Controller) με την εξαίρεση ότι δε χρησιμοποιείται 
το "View" μέρος της αρχιτεκτονικής. Τα αποτελέσματα από τα Spring Queries φαίνονται εύκολα στη Βάση 
Δεδομένων και στο Postman (παρουσιάζεται στο επόμενο βήμα). Ο **λόγος** για τον οποίο επιλέχθηκε το 
συγκεκριμένο pattern είναι επειδή, σε περίπτωση που θέλουμε να **παρουσιάσουμε** τις **αλλαγές** στον Client, 
μπορούμε να το κάνουμε εύκολα **αξιοποιώντας** το **"View"** layer της αρχιτεκτονικής. Επίσης, είναι κατά 
κόρων **προτεινόμενη τακτική** από έμπειρους προγραμματιστές σε **Java SpringBoot**.

_**Τα Dependencies κι εργαλεία που χρησιμοποιήθηκαν:**_
Χρησιμοποιώντας την **ιστοσελίδα start.spring.io** επιλέγουμε τα εξής dependencies:
1) **Spring Data J.P.A.**
2) **Spring WEB**
3) **<artifactId>modelmapper</artifactId>** (δεν υπάρχει στην start.spring.io)
4) **H2 Database**
5) **Lombok**
6) **Postman** Desktop Application.

_**Η λογική με την οποία στήθηκε η Σχεσιακή Βάση Δεδομένων:**_
Η Βάση Δεδομένων λειτουργεί ως εξής, Υπάρχουν δύο **πίνακες-οντότητες** για τις οποίες θέλουμε να β, η 
**Match και η MatchOdds**. Η **Match** πρέπει να περιέχει **στοιχεία** όπως: το **ID** της εγγραφής, την **ημέρα** κι **ώρα** του **αγώνα**, 
τις **ομάδες** που παίζουν κ.ά. που αναγράφονται στην εκφώνηση της εργασίας. Αντιστοίχως, η **MatchOdds** οφείλει να 
περιέχει **στοιχεία** όπως: το **ID** της εγγραφής, το **αποτέλεσμα** του αγώνα (specifier...?), την **πιθανότητα** να έρθει το 
συγκεκριμένο αποτέλεσμα κ.ά. που αναγράφονται στην εκφώνηση της εργασίας. Οι δύο πίνακες-οντότητες **συνδέονται** μεταξύ τους με 
Ένα-προς-Ένα (**@OneToOne**) **relation**. Το **field** που **συσχετίζει** τους πίνακες είναι το **ID του Match**, το οποίο είναι 
**Primary-Key** και **Foreign-Key** του **MatchOdds**.

_**Η βασική ιδέα και οι λειτουργίες των...:**_
1) .models: Είναι η **βασική δομή** των **οντοτήτων** που περιέχονται μέσα στη **Σχεσιακή Βάση Δεδομένων**.
2) .repositories: Παρέχουν **C.R.U.D. Services** για τη **διαχείριση** κι **αλληλεπίδραση** των **δεδομένων** από και προς τη Βάση.
3) .controllers: Οι **controllers** είναι υπεύθυνοι για τη **διαχείριση των requests** στον Server. Για παράδειγμα, όταν ο χρήστης-client 
**ζητάει** να δει μια **εγγραφή** από τη **Βάση Δεδομένων**, το **ερώτημα** αυτό **αποστέλλεται** στον **controller** κι αυτός **φροντίζει** για το ποιές 
μεθόδους ή κλάσεις ή services θα **καλέσει** ώστε να **επιστραφεί** πίσω το επιθυμητό **αποτέλεσμα**.
4) .dtos: Είναι ειδική κατηγορία κλάσεων οι οποίες **λαμβάνουν δεδομένα** από τον server (π.χ. αποτέλεσμα από request του client) και τα **μετατρέπουν** σε **μορφή 
εγγράφου** (String objects σε γλώσσα Java) **ή** και το **αντίστροφο**. Αυτό γίνεται γιατί η **μεταφορά** των **δεδομένων** **από** και **προς** τη **Βάση** χρησιμοποιούν **Jason** η οποία 
**απαιτεί** αυτή τη **συγκεκριμένη διαδικασία**.
5) .config: Υπάρχει για να **δημιουργήσει** Beans για τη Java. Τα **Beans** είναι εντολές που **εκτελούνται πριν** από το **run time** του **κώδικα**, ώστε να **αρχικοποιηθούν** κάποια 
απαραίτητα **implementations** κάποιων **services**. Στη συγκεκριμένη περίπτωση, έχουμε μόνο ένα **Bean** το οποίο **αρχικοποιεί implementation** για την κλάση **ModelMapper**. Η **κλάση** αυτή παρέχει **μεθόδους** 
με τις οποίες μπορούμε να **αντιστοιχήσουμε** τα ήδη **υπάρχοντα δεδομένα** από τη **Βάση Δεδομένων** με τα **repositories** μέσα στον κώδικα και να δουλέψουμε πάνω σε αυτά. Αν δε γινόταν αυτό, δε θα 
μπορούσαμε να έχουμε πρόσβαση στα δεδομένα αυτά.

_**Τα Annotations (πλευρά Spring) και η επιρροή τους στον κώδικα:**_
Τα **Annotations** είναι κομμάτια-blocks από κώδικα, ήδη **έτοιμα** από την **Java Spring**. Ουσιαστικά, **βοηθούν** τον developer να κάνει τυπικές **διαδικασίες** κι **εντολές** πολύ **γρηγορότερα**, αποφεύγοντας 
να γράφει συνέχεια τις ίδιες εντολές. Για παράδειγμα, στο package .model υπάρχουν οι κλάσεις Match και MatchOdds οι οποίες είναι πίνακες μέσα στη Βάση Δεδομένων. Αυτά πρέπει να έχουν **μοναδικά κλειδιά** 
(Primary Keys) κι αυτό **βάσει Java Spring** συμβολίζεται με το Annotation "**@Id**". Όταν θέλουμε το **κλειδί** αυτό να **αναπαράγεται αυτομάτως** από τη Βάση Δεδομένων, βάσει **Java Spring** το συμβολίζουμε με το 
"**@GeneratedValue(strategy = GenerationType.IDENTITY)**". Αυτό σημαίνει ότι το **κλειδί** θα αναπαράγεται **αυτομάτως** με **βάσει** το **object** της **κλάσης** στο οποίο και υπάρχει μέσα. Μέσα στο package .controllers υπάρχει μία 
κλάση ονόματι "SingleController". Αυτή έχει διάφορα Annotations όπως **@Controller**, **@RequestMapping**, **@GetMapping**, **@PutMapping** κ.ά. Το πρώτο, β στη Java ότι η συγκεκριμένη **κλάση** είναι ένας **Controller** κι έτσι 
οτιδήποτε **requests** σταλθούν από τον **client**, Java θα **ψάξει** πρώτα κάποιον β που να αποδέχεται **ανταλλαγή πληροφοριών** από και προς τέτοια **paths**. Το **@RequestMapping υποδεικνύει** ότι ο συγκεκριμένος Controller 
δέχεται **requests** που χρησιμοποιούν το **συγκεκριμένο path** (π.χ. localhost:8080/match στην περίπτωση του δικού μας Controller). Το **@GetMapping** δείχνει ότι ο χρήστης ζήτησε να "τραβήξει" **πληροφορία** από τη **Βάση Δεδομένων** 
κι ο **Controller** του **επιστρέφει** το επιθυμητό **αποτέλεσμα**. Το **@PutMapping** κάνει μια αλλαγή-**επεξεργασία** πάνω σε μια ήδη υπάρχουσα **εγγραφή** στη Βάση, ενώ το **@PostMapping** δημιουργεί μια **νέα εγγραφή** σε αυτήν (ή διαγράφει από αυτήν).
Το **@ResponseBody** αποστέλλει το **αποτέλεσμα** του **κώδικα**, μέσω **Jason**, στη **Βάση Δεδομένων** για εκτέλεση των εντολών, ενώ το **@RequestBody** "τραβάει" **δεδομένα** που έχει εισάγει ο **client** ώστε να μπορέσει ο κώδικάς μας να τα αξιοποιήσει 
και να δώσει το αποτέλεσμα.

_**Το αποτέλεσμα του κώδικα:**_
Ζητήθηκε να παραδοθεί ένα functional web service, που τρέχει αυτόνομα (ή σε docker) το ποίο να είναι σε θέση να εκτελεί Restful Requests προς μία Βάση Δεδομένων. Έτσι έχει υλοποιηθεί λοιπόν για Requests που αφορούν μόνο την κλάση Match, αφού 
η διαδικασία είναι ακριβώς η ίδια για την κλάση MatchOdds. Αν κάτι έχει ξεφύγει ή δεν έχει εξηγηθεί σωστά, μετά χαράς να το εξηγήσω προσωπικά και με λεπτομέρεια.